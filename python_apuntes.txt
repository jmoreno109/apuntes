
https://github.com/OpenWebinarsNet/curso_python3

idle - editor basico

ipython - es un shell interactivo que añade funcionalidades extra al modo interactivo incluido con Python
pip install ipython==2.3.0

// VARIABLE DE ENTORNO

C:\Users\Julian Moreno\AppData\Local\Programs\Python\Python36-32 
C:\Users\Julian Moreno\AppData\Local\Programs\Python\Python36-32\Scripts\

PIP is a package management system used to install and manage software packages written in Python
python -m pip install -U pip

#!/usr/bin/env python - sheban para linux 
$ chmod +x hola.py
$ ./hola.py
$ Hola mundo!!!


// ENTORNOS VIRTUALES

pip install virtualenv
cd my_project
virtualenv env

virtualenv venv
venv\Scripts\activate.bat (Windows)
. venv/bin/activate (Linux/mac)
pip install -r requirements.txt

deactivate(salir)


#!/usr/bin/env python    

# Sangrado con 4 espacios    

edad = 23
if edad > =18:
   print('Es mayor de edad')  
else:
   print('Es menor de edad')    

# Cada bloque de instrucciones dentro de una estructura de control
# debe estar tabulada    

if num >=0:
    while num<10:
        print (num)
        num = num +1    

# El punto y coma “;” se puede usar para separar varias sentencias 
# en una misma línea, pero no se aconseja su uso.    

edad = 15; print(edad)    

# Cuando el bloque a sangrar sólo ocupa una línea ésta puede
# escribirse después de los dos puntos:       

if azul: print('Cielo')    

# La barra invertida “\” permite escribir una línea de
# código demasiado extensa en varias líneas:    

if condicion1 and condicion2 and condicion3 and \  
    condicion4 and condicion5:    

# Las expresiones entre paréntesis, llaves o corchetes pueden 
# ocupar varias líneas:    

dias = ['lunes', 'martes', 'miércoles', 'jueves',
        'viernes', 'sábado', 'domingo'] 		
		

La entrada y salida de información se hacen con la función print y la función input
Tenemos algunas funciones matemáticas como: abs, divmod, hex, max, min,…
Hay funciones que trabajan con caracteres y cadenas: ascii, chr, format, repr
Además tenemos funciones que crean o convierten a determinados tipos de datos: int, float, str, bool, range, dict, list,

En el módulo builtins se definen las siguientes constantes:
True y False: Valores booleans
None especifica que alguna variables u objeto no tiene asignado ningún tipo.

Tipos númericos
Tipo entero (int)
Tipo real (float)
Tipo numérico (complex)
Tipos booleanos (bool)
Tipo de datos secuencia
Tipo lista (list)
Tipo tuplas (tuple)
Tipo rango (range)
Tipo de datos cadenas de caracteres
Tipo cadena (str)
Tipo de datos binarios
Tipo byte (bytes)
tipo bytearray (bytearray)
Tipo de datos conjuntos
Tipo conjunto (set)
Tipo conjunto inmutable (frozenset)
Tipo de datos iterador y generador (iter)
Tipo de datos mapas o diccionario (dict)


// FORMATEANDO CADENAS DE CARACTERES

>>> print("%d %f %s" % (2.5,2.5,2.5))
2 2.500000 2.5

>>> print("%s %o %x"%(bin(31),31,31))
0b11111 37 1f

>>> print("El producto %s cantidad=%d precio=%.2f"%("cesta",23,13.456))
El producto cesta cantidad=23 precio=13.46    


// Función format()
>>> print(format(31,"b"),format(31,"o"),format(31,"x"))
11111 37 1f

>>> print(format(2.345,".2f"))
2.35

// EXPRESIÓN REDUCIDA DEL IF
>>> lang="es"
>>> saludo = 'HOLA' if lang=='es' else 'HI'
>>> saludo
'HOLA'

// for
for i in range(1,10):
    print (i)
else:
    print ("Hemos terminado")


// FUNCION ZIP
>>> for x,y in zip(range(1,4),["ana","juan","pepe"]):
...     print(x,y)    
1 ana
2 juan
3 pepe


// SLICE: VEAMOS COMO SE PUEDE UTILIZAR

lista[start:end] # Elementos desde la posición start hasta end-1
lista[start:] # Elementos desde la posición start hasta el final
lista[:end] # Elementos desde el principio hata la posición end-1
lista[:] # Todos Los elementos
lista[start:end:step] # Igual que el anterior pero dando step saltos. Se pueden utilizar también índices negativos, por ejemplo: lista[::-1]


//FUNCIONES PREDEFINIDAS QUE TRABAJAN CON LISTAS

>>> lista1 = [20,40,10,40,50]
>>> len(lista1)
5
>>> max(lista1)
50
>>> min(lista1)
10
>>> sum(lista1)
150
>>> sorted(lista1)
[10, 20, 30, 40, 50]
>>> sorted(lista1,reverse=True)
[50, 40, 30, 20, 10]


// ¿CÓMO SE COPIAN LAS LISTAS?

Por lo tanto si queremos copiar una lista en otra podemos hacerlo de varias formas:

>>> lista1 = [1,2,3]
>>> lista2=lista1[:]
>>> lista1[1] = 10
>>> lista2
[1, 2, 3]
>>> lista2 = list(lista1)
>>> lista2 = lista1.copy()

// METODOS DE LISTAS

Métodos de inserción: append, extend, insert
>>> lista = [1,2,3]
>>> lista.append(4)
>>> lista
[1, 2, 3, 4]

>>> lista2 = [5,6]
>>> lista.extend(lista2)
>>> lista
[1, 2, 3, 4, 5, 6]    

>>> lista.insert(1,100)
>>> lista
[1, 100, 2, 3, 4, 5, 6]

Métodos de eliminación: pop, remove
>>> lista.pop()
6
>>> lista
[1, 100, 2, 3, 4, 5]

>>> lista.pop(1)
100
>>> lista
[1, 2, 3, 4, 5]

>>> lista.remove(3)
>>> lista
[1, 2, 4, 5]

Métodos de ordenación: reverse, sort,
>>> lista.reverse()
>>> lista
[5, 4, 2, 1]

>>> lista.sort()
>>> lista
[1, 2, 4, 5]

>>> lista.sort(reverse=True)
>>> lista
[5, 4, 2, 1]

>>> lista=["hola","que","tal","Hola","Que","Tal"]
>>> lista.sort()
>>> lista
['Hola', 'Que', 'Tal', 'hola', 'que', 'tal']
>>> lista=["hola","que","tal","Hola","Que","Tal"]
>>> lista.sort(key=str.lower)
>>> lista
['hola', 'Hola', 'que', 'Que', 'tal', 'Tal']

Métodos de búsqueda: count, index
>>> lista.count(5)
1

>>> lista.append(5)
>>> lista
[5, 4, 2, 1, 5]
>>> lista.index(5)
0
>>> lista.index(5,1)
4
>>> lista.index(5,1,4)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: 5 is not in list
Método de copia: copy
>>> lista2 = lista1.copy()


// PROGRAMACION FUNCIONAL

Función map
map(funcion,secuencia): Ejecuta la función enviada por parámetro sobre cada uno de los elementos de la secuencia.

Ejemplo

>>> items = [1, 2, 3, 4, 5]
>>> def sqr(x): return x ** 2
>>> list(map(sqr, items))
[1, 4, 9, 16, 25]
Función filter
filter(funcion,secuencia): Devuelve una secuencia con los elementos de la secuencia envíada por parámetro que devuelvan True al aplicarle la función envíada también como parámetro.

Ejemplo

>>> lista = [1,2,3,4,5]
>>> def par(x): return x % 2==0 
>>> list(filter(par,lista))
Función reduce
reduce(funcion,secuencia): Devuelve un único valor que es el resultado de aplicar la función á los lementos de la secuencia.

Ejemplo

>>> from functools import reduce
>>> lista = [1,2,3,4,5]
>>> def add(x,y): return x + y
>>> reduce(add,lista)
15
list comprehension
list comprehension nos propociona una alternativa para la creación de listas. Es parecida a la función map, pero mientras map ejecuta una función por cada elemento de la secuencia, con esta técnica se aplica una expresión.

Ejemplo

>>> [x ** 3 for x in [1,2,3,4,5]]
[1, 8, 27, 64, 125]

>>> [x for x in range(10) if x % 2 == 0]
[0, 2, 4, 6, 8] 

>>> [x + y for x in [1,2,3] for y in [4,5,6]]
[5, 6, 7, 6, 7, 8, 7, 8, 9]


// RANGOS

Definición de un rango. Constructor range
Al crear un rango (secuencia de números) obtenemos un objeto que es de la clase range:

>>> rango = range(0,10,2)
>>> type(rango)
<class 'range'>
Veamos algunos ejemplos, convirtirndo el rango en lista para ver la secuencia:

>>> list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> list(range(0, 30, 5))
[0, 5, 10, 15, 20, 25]
>>> list(range(0, 10, 3))
[0, 3, 6, 9]
>>> list(range(0, -10, -1))
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9


// MÉTODOS DE FORMATO

>>> cad = "hola, como estás?"
>>> print(cad.capitalize())
Hola, como estás?

>>> cad = "Hola Mundo" 
>>> print(cad.lower())
hola mundo

>>> cad = "hola mundo"
>>> print(cad.upper())
HOLA MUNDO

>>> cad = "Hola Mundo"
>>> print(cad.swapcase())
hOLA mUNDO

>>> cad = "hola mundo"
>>> print(cad.title())
Hola Mundo

>>> print(cad.center(50))
                    hola mundo                    
>>> print(cad.center(50,"="))
====================hola mundo====================

>>> print(cad.ljust(50,"="))
hola mundo========================================
>>> print(cad.rjust(50,"="))
========================================hola mundo

>>> num = 123
>>> print(str(num).zfill(12))
000000000123

// MÉTODOS DE BÚSQUEDA

>>> cad = "bienvenido a mi aplicación"
>>> cad.count("a")
3
>>> cad.count("a",16)
2
>>> cad.count("a",10,16)
1

>>> cad.find("mi")
13
>>> cad.find("hola")
-1

>>> cad.rfind("a")
21
El método index() y rindex() son similares a los anteriores pero provocan una excepción ValueError cuando no encuentra la subcadena.

// MÉTODOS DE VALIDACIÓN

>>> cad.startswith("b")
True
>>> cad.startswith("m")
False
>>> cad.startswith("m",13)
True

>>> cad.endswith("ción")
True
>>> cad.endswith("ción",0,10)
False
>>> cad.endswith("nido",0,10)
True
Otras funciones de validación: isalnum(), isalpha(), isdigit(), islower(), isupper(), isspace(), istitle(),…

// MÉTODOS DE SUSTITUCIÓN

format
En la unidad “Entrada y salida estándar” ya estuvimos introduciendo el concepto de formateo de la cadenas. Estuvimos viendo que hay dos métodos y vimos algunos ejemplos del nuevo estilo con la función predefinida format().

El uso del estilo nuevo es actualmente el recomendado (puedes obtener más información y ejemplos en algunos de estos enlaces: enlace1 y enlace2) y obtiene toda su potencialidad usando el método format() de las cadenas. Veamos algunos ejemplos:

>>> '{} {}'.format("a", "b")
'a b'
>>> '{1} {0}'.format("a", "b")
'b a'
>>> 'Coordenadas: {latitude}, {longitude}'.format(latitude='37.24N', longitude='-115.81W')
'Coordenadas: 37.24N, -115.81W'
>>> '{0:b} {1:x} {2:.2f}'.format(123, 223,12.2345)
'1111011 df 12.23'
>>> '{:^10}'.format('test')
'   test   '

// OTROS MÉTODOS DE SUSTITUCIÓN

>>> buscar = "nombre apellido"
>>> reemplazar_por = "Juan Pérez" 
>>> print ("Estimado Sr. nombre apellido:".replace(buscar, reemplazar_por)) 
Estimado Sr. Juan Pérez:

>>> cadena = "   www.eugeniabahit.com   " 
>>> print(cadena.strip())
www.eugeniabahit.com
>>> cadena="00000000123000000000"
>>> print(cadena.strip("0"))
123
De forma similar lstrip(["caracter"]) y rstrip(["caracter"]).


// MÉTODOS DE UNIÓN Y DIVISIÓN

>>> formato_numero_factura = ("Nº 0000-0", "-0000 (ID: ", ")"
>>> print("275".join(formato_numero_factura))
Nº 0000-0275-0000 (ID: 275)

>>> hora = "12:23"
>>> print(hora.rpartition(":"))
('12', ':', '23')
>>> print(hora.partition(":"))
('12', ':', '23')
>>> hora = "12:23:12"
>>> print(hora.partition(":"))
('12', ':', '23:12')
>>> print(hora.split(":"))
['12', '23', '12']
>>> print(hora.rpartition(":"))
('12:23', ':', '12')
>>> print(hora.rsplit(":",1))
['12:23', '12']
>>> texto = "Linea 1\nLinea 2\nLinea 3" 
>>> print(texto.splitlines())
['Linea 1', 'Linea 2', 'Linea 3']



// MÉTODOS ENCODE Y DECODE BYTES

Los caracteres cuyo código es mayor que 256 no se pueden usar para representar los bytes, sin embargo si podemos indicar una codificación de caracteres determinada para que ese carácter se convierte en un conjunto de bytes.

>>> byte1=b'piña'
  File "<stdin>", line 1
SyntaxError: bytes can only contain ASCII literal characters.
>>> byte1=bytes('piña',"utf-8")
>>> byte1
b'pi\xc3\xb1a'
>>> len(byte1)
5
>>> byte1=bytes('piña',"latin1")
>>> byte1
b'pi\xf1a'
Podemos también convertir una cadena unicode a bytes utilizando el método encode:

>>> cad="piña"
>>> byte1=cad.encode("utf-8")
>>> byte1
b'pi\xc3\xb1a'
Para hacer la función inversa, convertir de bytes a unicode utilizamos el método decode:

>>> byte1.decode("utf-8")
'piña'
El problema lo tenemos si hemos codificado utilizando un código e intentamos decodificar usando otro.

>>> byte1=bytes('piña',"latin1")
>>> byte1.decode("utf-8")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xf1 in position 2: invalid continuation byte
>>> byte1.decode("utf-8","ignore")
'pia'
>>> byte1.decode("utf-8","replace")
'pi�a'


// MÉTODOS DE SET Y FROZENSET

Veamos algunos métodos, partiendo siempre de estos dos conjuntos:

>>> set1={1,2,3}
>>> set2={2,3,4}

>>> set1.difference(set2)
{1}
>>> set1.difference_update(set2)
>>> set1
{1}

>>> set1.symmetric_difference(set2)
{1, 4}
>>> set1.symmetric_difference_update(set2)
>>> set1
{1, 4}

>>> set1.intersection(set2)
{2, 3}
>>> set1.intersection_update(set2)
>>> set1
{2, 3}

>>> set1.union(set2)
{1, 2, 3, 4}
>>> set1.update(set2)
>>> set1
{1, 2, 3, 4}
Veamos los métodos de añadir y eliminar elementos:

>>> set1 = set()
>>> set1.add(1)
>>> set1.add(2)
>>> set1
{1, 2}
>>> set1.discard(3)
>>> set1.remove(3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 3
>>> set1.pop()
1
>>> set1
{2}
Y los métodos de comprobación:

>>> set1 = {1,2,3}
>>> set2 = {1,2,3,4}
>>> set1.isdisjoint(set2)    
False
>>> set1.issubset(set2)
True
>>> set1.issuperset(set2)
False
>>> set2.issuperset(set1)
True


Iterador
Un objeto iterable es aquel que puede devolver un iterador. Normalmente las colecciones que hemos estudiados son iterables. Un iterador me permite recorrer los elementos del objeto iterable.

Definición de iterador. Constructor iter
>>> iter1 = iter([1,2,3])
>>> type(iter1)
<class 'list_iterator'>
>>> iter2 = iter("hola")
>>> type(iter2)
<class 'str_iterator'>
Función next(), reversed()
Para recorrer el iterador, utilizamos la función next():

>>> next(iter1)
1
>>> next(iter1)
2
>>> next(iter1)
3
>>> next(iter1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
La función reversed() devuelve un iterador con los elementos invertidos, desde el último al primero.

>>> iter2 = reversed([1,2,3])
>>> next(iter2)
3
>>> next(iter2)
2
>>> next(iter2)
1
>>> next(iter2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration    
El módulo itertools
El módulo itertools contiene distintas funciones que nos devuelven iteradores.

Veamos algunos ejemplos:

count(): Devuelve un iterador infinito.

>>> from itertools import count
>>> counter = count(start=13)
>>> next(counter)
13
>>> next(counter)
14
cycle(): devuelve una secuencia infinita.

>>> from itertools import cycle
>>> colors = cycle(['red', 'white', 'blue'])
>>> next(colors)
'red'
>>> next(colors)
'white'
>>> next(colors)
'blue'
>>> next(colors)
'red'
islice(): Retorna un iterador finito.

>>> from itertools import islice
>>> limited = islice(colors, 0, 4) 
>>> for x in limited: 
...   print(x) 
white
blue
red
white
Generadores
Un generador es un tipo concreto de iterador. Es una función que permite obtener sus resultados paso a paso. Por ejemplo, hacer una función que cada vez que la llamemos nos de el próximo número par. Tenemos dos maneras de crear generadores:

Realizar una función que devuelva los valores con la palabra reservada yield. Lo veremos con profundidad cuando estudiemos las funciones.

Utilizando la sintaxis de las “list comprehension”. Por ejemplo: 
 >>> iter1 = (x for x in range(10) if x % 2==0)
 >>> next(iter1)
 0
 >>> next(iter1)
 2
 >>> next(iter1)
 4
 
 
 
 
dict1.clear       dict1.get         dict1.pop         dict1.update      
dict1.copy        dict1.items       dict1.popitem     dict1.values      
dict1.fromkeys    dict1.keys        dict1.setdefault  
Métodos de eliminación: clear
>>> dict1 = dict(one=1, two=2, three=3)
>>> dict1.clear()
>>> dict1
{}
Métodos de agregado y creación: copy, dict.fromkeys, update, setdefault
>>> dict1 = dict(one=1, two=2, three=3)
>>> dict2 = dict1.copy()

>>> dict.fromkeys(["one","two","three"])
{'one': None, 'two': None, 'three': None}
>>> dict.fromkeys(["one","two","three"],100)
{'one': 100, 'two': 100, 'three': 100}

>>> dict1 = dict(one=1, two=2, three=3)
>>> dict2 = {'four':4,'five':5}
>>> dict1.update(dict2)
>>> dict1
{'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5}

>>> dict1 = dict(one=1, two=2, three=3)
>>> dict1.setdefault("four",4)
4
>>> dict1
{'one': 1, 'two': 2, 'three': 3, 'four': 4}
>>> dict1.setdefault("one",-1)
1
>>> dict1
{'one': 1, 'two': 2, 'three': 3, 'four': 4}
Métodos de retorno: get, pop, popitem, items, keys, values
>>> dict1 = dict(one=1, two=2, three=3)
>>> dict1.get("one")
1
>>> dict1.get("four")
>>> dict1.get("four","no existe")
'no existe'

>>> dict1.pop("one")
1
>>> dict1
{'two': 2, 'three': 3}
>>> dict1.pop("four")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'four'
>>> dict1.pop("four","no existe")
'no existe'

>>> dict1 = dict(one=1, two=2, three=3)
>>> dict1.popitem()
('one', 1)
>>> dict1
{'two': 2, 'three': 3}

>>> dict1 = dict(one=1, two=2, three=3)
>>> dict1.items()
dict_items([('one', 1), ('two', 2), ('three', 3)])

>>> dict1.keys()
dict_keys(['one', 'two', 'three'])
El tipo de datos dictviews
Los tres últimos métodos devuelven un objeto de tipo dictviews.

Esto devuelve una vista dinámica del ciccionario, por ejemplo:

>>> dict1 = dict(one=1, two=2, three=3)
>>> i = dict1.items()
>>> i
dict_items([('one', 1), ('two', 2), ('three', 3)])
>>> dict1["four"]=4
>>> i
dict_items([('one', 1), ('two', 2), ('three', 3), ('four', 4)])
Es este tipo de datos podemos usar las siguientes funciones:

len(): Devuelve número de elementos de la vista.
iter(): Nos devuelve un iterador de las claves, valores o ambas.
x in dictview: Devuelve True si x está en las claves o valores.
Recorrido de diccionarios
Podemos recorrer las claves:

>>> for clave in dict1.keys():
...    print(clave)
one
two
three
Podemos recorrer los valores:

>>> for valor in dict1.values():
...    print(valor) 
1
2
3
O podemos recorrer ambos:

>>> for clave,valor in dict1.items():
...   print(clave,"->",valor)
one -> 1
two -> 2
three -> 3



// FICHEROS DE TEXTOS

Función open()
La función open() se utiliza normalmente con dos parámetros (fichero con el que vamos a trabajar y modo de acceso) y nos devuelve un objeto de tipo fichero.

>>> f = open("ejemplo.txt","w")
>>> type(f)
<class '_io.TextIOWrapper'>
>>> f.close()
Modos de acceso
Los modos que podemos indicar son los siguientes:

Añadido en modo binario. Crea si éste no existe
Modo	Comportamiento	Puntero
r	Solo lectura	Al inicio del archivo
rb	Solo lectura en modo binario	
r+	Lectura y escritura	Al inicio del archivo
rb+	Lectura y escritura binario	Al inicio del archivo
w	Solo escritura. Sobreescribe si existe. Crea el archivo si no existe.	Al inicio del archivo
wb	Solo escritura en modo binario. Sobreescribe si existe. Crea el archivo si no existe.	Al inicio del archivo
w+	Escritura y lectura. Sobreescribe si existe. Crea el archivo si no existe.	Al inicio del archivo
wb+	Escritura y lectura binaria. Sobreescribe si existe. Crea el archivo si no existe.	Al inicio del archivo
a	Añadido (agregar contenido). Crea el archivo si no existe.	Si el archivo existe, al final de éste. Si el archivo no existe, al comienzo.
ab		Si el archivo existe, al final de éste. Si el archivo no existe, al comienzo.
a+	Añadido y lectura. Crea el archivo si no existe.	Si el archivo existe, al final de éste. Si el archivo no existe, al comienzo.
ab+	Añadido y lectura en binario. Crea el archivo si no existe	Si el archivo existe, al final de éste. Si el archivo no existe, al comienzo.
Como podemos comprobar podemos trabajar con ficheros binarios y con ficheros de textos.

Codificación de caracteres
Si trabajamos con fichero de textos podemos indicar también el parámetro encoding que será la codificación de caracteres utilizadas al trabajar con el fichero, por defecto se usa la indicada en el sistema:

>>> import locale
>>> locale.getpreferredencoding()
'UTF-8'
Y por último también podemos indicar el parámetro errors que controla el comportamiento cuando se encuentra con algún error al codificar o decodificar caracteres.

Objeto fichero
Al abrir un fichero con un determinado modo de acceso con la función open() se nos devuelve un objeto fichero. El fichero abierto siempre hay que cerrarlo con el método close():

>>> f = open("ejemplo.txt","w")
>>> type(f)
<class '_io.TextIOWrapper'>
>>> f.close()
Se pueden acceder a las siguientes propiedades del objeto file:

closed: retorna True si el archivo se ha cerrado. De lo contrario, False.
mode: retorna el modo de apertura.
name: retorna el nombre del archivo
encoding: retorna la codificación de caracteres de un archivo de texto
Podemos abrirlo y cerrarlo en la misma instrucción con la siguiente estructura:

>>> with open("ejemplo.txt", "r") as archivo: 
...    contenido = archivo.read()
>>> archivo.closed
True
Métodos principales
Métodos de lectura
>>> f = open("ejemplo.txt","r")
>>> f.read()
'Hola que tal\n'

>>> f = open("ejemplo.txt","r")
>>> f.read(4)
'Hola'
>>> f.read(4)
' que'
>>> f.tell()
8
>>> f.seek(0)
>>> f.read()
'Hola que tal\n'

>>> f = open("ejemplo2.txt","r")    
>>> f.readline()
'Línea 1\n'
>>> f.readline()
'Línea 2\n'
>>> f.seek(0)
0
>>> f.readlines()
['Línea 1\n', 'Línea 2\n']
Métodos de escritura
>>> f = open("ejemplo3.txt","w")
>>> f.write("Prueba 1\n")
9
>>> print("Prueba 2\n",file=f)
>>> f.writelines(["Prueba 3","Prueba 4"])
>>> f.close()
>>> f = open("ejemplo3.txt","r")
>>> f.read()
'Prueba 1\nPrueba 2\n\nPrueba 3Prueba 4'
Recorrido de ficheros
>>> with open("ejemplo3.txt","r") as fichero:
...    for linea in fichero:
...        print(linea)




// MÓDULO CSV

El módulo cvs nos permite trabajar con ficheros CSV.


Un fichero CSV (comma-separated values) son un tipo de documento en formato abierto sencillo para representar datos en forma de tabla, en las que las columnas se separan por comas (o por otro carácter).

Leer ficheros CSV
Para leer un fichero CSV utilizamos la función reader():

>>> import csv
>>> fichero = open("ejemplo1.csv")
>>> contenido = csv.reader(fichero)
>>> list(contenido)
[['4/5/2015 13:34', 'Apples', '73'], ['4/5/2015 3:41', 'Cherries', '85'], ['4/6/2015 12:46', 'Pears', '14'], ['4/8/2015 8:59', 'Oranges', '52'], ['4/10/2015 2:07', 'Apples', '152'], ['4/10/2015 18:10', 'Bananas', '23'], ['4/10/2015 2:40', 'Strawberries', '98']]
>>> list(contenido)
[]
>>> fichero.close()
Podemos guardar la lista obtenida en una variable y acceder a ella indicando fila y columna.

...
>>> datos = list(contenido)
>>> datos[0][0]
'4/5/2015 13:34'
>>> datos[1][1]
'Cherries'
>>> datos[2][2]
'14'
Por supuesto podemos recorrer el resultado:

...
>>> for row in contenido:
    print("Fila "+str(contenido.line_num)+" "+str(row))    

Fila 1 ['4/5/2015 13:34', 'Apples', '73']
Fila 2 ['4/5/2015 3:41', 'Cherries', '85']
Fila 3 ['4/6/2015 12:46', 'Pears', '14']
Fila 4 ['4/8/2015 8:59', 'Oranges', '52']
Fila 5 ['4/10/2015 2:07', 'Apples', '152']
Fila 6 ['4/10/2015 18:10', 'Bananas', '23']
Fila 7 ['4/10/2015 2:40', 'Strawberries', '98']
Veamos otro ejemplo un poco más complejo:

>>> import csv
>>> fichero = open("ejemplo2.csv")
>>> contenido = csv.reader(fichero,quotechar='"')
>>> for row in contenido:
...   print(row)
... 
['Año', 'Marca', 'Modelo', 'Descripción', 'Precio']
['1997', 'Ford', 'E350', 'ac, abs, moon', '3000.00']
['1999', 'Chevy', 'Venture "Extended Edition"', '', '4900.00']
['1999', 'Chevy', 'Venture "Extended Edition, Very Large"', '', '5000.00']
['1996', 'Jeep', 'Grand Cherokee', 'MUST SELL!\nair, moon roof, loaded', '4799.00']
Escribir ficheros CSV
>>> import csv
>>> fichero = open("ejemplo3.csv","w")
>>> contenido = csv.writer(fichero)
>>> contenido.writerow(['4/5/2015 13:34', 'Apples', '73'])
>>> contenido.writerows(['4/5/2015 3:41', 'Cherries', '85'],['4/6/2015 12:46', 'Pears', '14'])
>>> fichero.close()

$ cat ejemplo3.csv
4/5/2015 13:34,Apples,73
4/5/2015 3:41,Cherries,85
4/6/2015 12:46,Pears,14


// Leer ficheros json
// Desde una cadena de caracteres:

>>> import json
>>> datos_json='{"nombre":"carlos","edad":23}'
>>> datos = json.loads(datos_json)
>>> type(datos)
<class 'dict'>
>>> print(datos)
{'nombre': 'carlos', 'edad': 23}


// Escribir ficheros json

>>> import json
>>> datos = {'isCat': True, 'miceCaught': 0, 'name': 'Zophie','felineIQ': None}
>>> fichero = open("ejemplo2.json","w")
>>> json.dump(datos,fichero)
>>> fichero.close()

cat ejemplo2.json 
{"miceCaught": 0, "name": "Zophie", "felineIQ": null, "isCat": true}




// MANEJANDO EXCEPCIONES. TRY, EXCEPT, ELSE, FINALLY

Veamos un ejemplo simple como podemos tratar una excepción:

>>> while True:
...   try:
...     x = int(input("Introduce un número:"))
...     break
...   except ValueError:
...     print ("Debes introducir un número")
Se ejecuta el bloque de instrucciones de try.

Si no se produce la excepción, el bloque de except no se ejecuta y continúa la ejecución secuencia.

Si se produce una excepción, el resto del bloque try no se ejecuta, si la excepción que se ha produce corresponde con la indicada en except se salta a ejecutar el bloque de instrucciones except.

Si la excepción producida no se corresponde con las indicadas en except se pasa a otra instrucción try, si finalmente no hay un manejador nos dará un error y el programa terminará.
Un bloque except puede manejar varios tipos de excepciones:

... except (RuntimeError, TypeError, NameError):
...     pass
Si quiero controlar varios tipos de excepciones puedo poner varios bloques except. Teniendo en cuenta que en el último, si quiero no indico el tipo de excepción:

>>> try:
...   print (10/int(cad))
... except ValueError:
...   print("No se puede converir a entero")
... except ZeroDivisionError:
...   print("No se puede divir por cero")
... except:
...   print("Otro error")
Se puede utilizar también la clausula else:

>>> try:
...   print (10/int(cad))
... except ValueError:
...   print("No se puede converir a entero")
... except ZeroDivisionError:
...   print("No se puede divir por cero")
... else:
...   print("Otro error")
Por último indicar que podemos indicar una clausula finally para indicar un bloque de instrucciones que siempre se debe ejecutar, independientemente de la excepción se haya producido o no.

>>> try:
...     result = x / y
... except ZeroDivisionError:
...     print("División por cero!")
... else:
...     print("El resultado es", result)
... finally:
...     print("Terminamos el programa")
Obteniendo información de las excepciones
>>> cad = "a"
>>> try:
...   i = int(cad)
... except ValueError as error:
...   print(type(error))
...   print(error.args)
...   print(error)
... 
<class 'ValueError'>
("invalid literal for int() with base 10: 'a'",)
invalid literal for int() with base 10: 'a'
Propagando excepciones. raise
Si construimos una función donde se maneje una excepción podemos hacer que la excepción se envía a la función desde la que la hemos llamado. Para ello utilizamos la instrucción raise. Veamos algunos ejemplos:

def dividir(x,y):
    try:
        return x/y
    except ZeroDivisionError:
        raise 
Con raise también podemos propagar una excepción en concreto:

def nivel(numero):
    if numero<0:
        raise ValueError("El número debe ser positivo:"+str(numero))
    else:
        return numero
		
		

// MODULOS


Python tiene sus propios módulos, los cuales forman parte de su librería de módulos estándar, que también pueden ser importados. En esta unidad vamos a estudiar las funciones porincipales de módulos realacionados con el sistema operativo.

Módulo os
El módulo os nos permite acceder a funcionalidades dependientes del Sistema Operativo. Sobre todo, aquellas que nos refieren información sobre el entorno del mismo y nos permiten manipular la estructura de directorios.

Descripción	Método
Saber si se puede acceder a un archivo o directorio	os.access(path, modo_de_acceso)
Conocer el directorio actual	os.getcwd()
Cambiar de directorio de trabajo	os.chdir(nuevo_path)
Cambiar al directorio de trabajo raíz	os.chroot()
Cambiar los permisos de un archivo o directorio	os.chmod(path, permisos)
Cambiar el propietario de un archivo o directorio	os.chown(path, permisos)
Crear un directorio	os.mkdir(path[, modo])
Crear directorios recursivamente	os.mkdirs(path[, modo])
Eliminar un archivo	os.remove(path)
Eliminar un directorio	os.rmdir(path)
Eliminar directorios recursivamente	os.removedirs(path)
Renombrar un archivo	os.rename(actual, nuevo)
Crear un enlace simbólico	os.symlink(path, nombre_destino)
>>> import os
>>> os.getcwd()
'/home/jose/github/curso_python3/curso/u40'
>>> os.chdir("..")
>>> os.getcwd()
'/home/jose/github/curso_python3/curso'
El módulo os también nos provee del submódulo path (os.path) el cual nos permite acceder a ciertas funcionalidades relacionadas con los nombres de las rutas de archivos y directorios.

Descripción	Método
Ruta absoluta	os.path.abspath(path)
Directorio base	os.path.basename(path)
Saber si un directorio existe	os.path.exists(path)
Conocer último acceso a un directorio	os.path.getatime(path)
Conocer tamaño del directorio	os.path.getsize(path)
Saber si una ruta es absoluta	os.path.isabs(path)
Saber si una ruta es un archivo	os.path.isfile(path)
Saber si una ruta es un directorio	os.path.isdir(path)
Saber si una ruta es un enlace simbólico	os.path.islink(path)
Saber si una ruta es un punto de montaje	os.path.ismount(path)
Ejecutar comandos del sistema operativo. Módulo subprocess
Con la función system() del módulo os nos permite ejecutar comandos del sistema operativo.

>>> os.system("ls")
curso  modelo.odp  README.md
0
La función nos devuelve un código para indicar si la instrucción se ha ejecutado con éxito.

Tenemos otra forma de ejecutar comandos del sistema operativo que nos da más funcionalidad, por ejemplo nos permite guardar la salida del comando en una variable. Para ello podemos usar el módulo subprocess

>>> import subprocess
>>> subprocess.call("ls")
curso  modelo.odp  README.md
0

>>> salida=subprocess.check_output("ls")
>>> print(salida.decode())
curso
modelo.odp
README.md

>>> salida=subprocess.check_output(["df","-h"])

>>> salida = subprocess.Popen(["df","-h"], stdout=subprocess.PIPE)
>>> salida.communicate()[0]
Módulo shutil
El módulo shutil de funciones para realizar operaciones de alto nivel con archivos y directorios. Dentro de las operaciones que se pueden realizar está copiar, mover y borrar archivos y directorios; y copiar los permisos y el estado de los archivos.

Descripción	Método
Copia un fichero complero o parte	shutil.copyfileobj(fsrc, fdst[, length])
Copia el contenido completo (sin metadatos) de un archivo	shutil.copyfile(src, dst, *, follow_symlinks=True)
copia los permisos de un archivo origen a uno destino	shutil.copymode(src, dst, *, follow_symlinks=True)
Copia los permisos, la fecha-hora del último acceso, la fecha-hora de la última modificación y los atributos de un archivo origen a un archivo destino	shutil.copystat(src, dst, *, follow_symlinks=True)
Copia un archivo (sólo datos y permisos)	shutil.copy(src, dst, *, follow_symlinks=True)
Copia archivos (datos, permisos y metadatos)	shutil.move(src, dst, copy_function=copy2)
Obtiene información del espacio total, usado y libre, en bytes	shutil.disk_usage(path)
Obtener la ruta de un archivo ejecutable	shutil.chown(path, user=None, group=None)
Saber si una ruta es un enlace simbólico	shutil.which(cmd, mode=os.F_OK | os.X_OK, path=None)
Módulos sys
El módulo sys es el encargado de proveer variables y funcionalidades, directamente relacionadas con el intérprete.

Algunas variables definidas en el módulo:

Variable	Descripción
sys.argv	Retorna una lista con todos los argumentos pasados por línea de comandos. Al ejecutar python modulo.py arg1 arg2, retornará una lista: ['modulo.py', 'arg1', 'arg2']
sys.executable	Retorna el path absoluto del binario ejecutable del intérprete de Python
sys.platform	Retorna la plataforma sobre la cuál se está ejecutando el intérprete
sys.version	Retorna el número de versión de Python con información adicional
Y algunos métodos:

Método	Descripción
sys.exit()	Forzar la salida del intérprete
sys.getdefaultencoding()	Retorna la codificación de caracteres por defecto
Ejecución de scripts con argumentos
Podemos enviar información (argumentos) a un programa cuando se ejecuta como un script, por ejemplo:

#!/usr/bin/env python    
import sys
print("Has instroducido",len(sys.argv),"argumento")
suma=0
for i in range(1,len(sys.argv)):
    suma=suma+int(sys.argv[i])
print("La suma es ",suma)

$  python3 sumar.py 3 4 5
Has introducido 4 argumento
La suma es  12






Módulo math
El módulo math nos proporciones distintas funciones y operaciones matemáticas.

>>> import math
>>> math.factorial(5)
120
>>> math.pow(2,3)
8.0
>>> math.sqrt(7)
2.6457513110645907
>>> math.cos(1)
0.5403023058681398
>>> math.pi
3.141592653589793
>>> math.log(10)
2.302585092994046
Módulo fractions
El módulo fractions nos permite trabajar con fracciones.

>>> from fractions import Fraction
>>> a=Fraction(2,3)
>>> b=Fraction(1.5)
>>> b
Fraction(3, 2)
>>> c=a+b
>>> c
Fraction(13, 6)
Módulo statistics
El módulo statistics nos proporciona funciones para hacer operaciones estadísticas.

>>> import statistics
>>> statistics.mean([1,4,5,2,6])
3.6

>>> statistics.median([1,4,5,2,6])
4
Módulo random
El módulo random nos permite generar datos pseudo-aleatorios.

>>> import random
>>> random.randint(10,100)
34

>>> random.choice(["hola","que","tal"])
'que'

>>> frutas=["manzanas","platanos","naranjas"]
>>> random.shuffle(frutas)
>>> frutas
['naranjas', 'manzanas', 'platanos']

>>> lista = [1,3,5,2,7,4,9]
>>> numeros=random.sample(lista,3)
>>> numeros
[1, 2, 4]






Módulo time
El tiempo es medido como un número real que representa los segundos transcurridos desde el 1 de enero de 1970. Por lo tanto es imposible representar fechas anteriores a esta y fechas a partir de 2038 (tamaño del float en la lubraría C (32 bits)).

>>> import time
>>> time.time()
1488619835.7858684
Para convertir la cantidad de segundos a la fecha y hora local:

>>> tiempo = time.time()
>>> time.localtime(tiempo)
time.struct_time(tm_year=2017, tm_mon=3, tm_mday=4, tm_hour=10, tm_min=37, tm_sec=19, tm_wday=5, tm_yday=63, tm_isdst=0)
Si queremos obtener la fecha y hora actual:

>>> time.localtime()
time.struct_time(tm_year=2017, tm_mon=3, tm_mday=4, tm_hour=10, tm_min=37, tm_sec=30, tm_wday=5, tm_yday=63, tm_isdst=0)
Nos devuelve a una estructura a la que podemos acceder a sus distintos campos.

>>> tiempo = time.localtime()
>>> tiempo.tm_year
2017
Podemos representar la fecha y hora como una cadena:

>>> time.asctime()
'Sat Mar  4 10:41:41 2017'
>>> time.asctime(tiempo)
'Sat Mar  4 10:39:21 2017'
O con un determinado formato:

>>> time.strftime('%d/%m/%Y %H:%M:%S')
'04/03/2017 10:44:52'
>>> time.strftime('%d/%m/%Y %H:%M:%S',tiempo)
'04/03/2017 10:39:21'
Módulo datetime
Los módulos datetime y calendar amplían las posibilidades del módulo time que provee funciones para manipular expresiones de tiempo.

>>> from datetime import datetime
>>> datetime.now()
datetime.datetime(2017, 3, 4, 10, 52, 12, 859564)
>>> datetime.now().day,datetime.now().month,datetime.now().year
(4, 3, 2017)
Para compara fechas y horas:

>>> from datetime import datetime, date, time, timedelta
>>> hora1 = time(10,5,0)
>>> hora2 = time(23,15,0)
>>> hora1>hora2
False

>>> fecha1=date.today()
>>> fecha2=fecha1+timedelta(days=2)
>>> fecha1
datetime.date(2017, 3, 4)
>>> fecha2
datetime.date(2017, 3, 6)
>>> fecha1<fecha2
True
Podemos imprimir aplicando un formato:

>>> fecha1.strftime("%d/%m/%Y")
'04/03/2017'
>>> hora1.strftime("%H:%M:%S")
'10:05:00'
Podemos convertir una cadena a un datetime:

>>> tiempo = datetime.strptime("12/10/2017","%d/%m/%Y")
Y podemos trabajar con cantidades (segundos, minutos, horas, días, semanas,…) con timedelta:

>>> hoy = date.today()
>>> ayer = hoy - timedelta(days=1)
>>> diferencia=hoy -ayer
>>> diferencia
datetime.timedelta(1)

>>> fecha1=datetime.now()
>>> fecha2=datetime(1995,10,12,12,23,33)
>>> diferencia=fecha1-fecha2
>>> diferencia
datetime.timedelta(7813, 81981, 333199)
Módulo calendar
Podemos obtener el calendario del mes actual:

>>> año = date.today().year 
>>> mes = date.today().month
>>> calendario_mes = calendar.month(año, mes)
>>> print(calendario_mes)
     March 2017
Mo Tu We Th Fr Sa Su
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30 31
Y para mostrar todos los meses del año:

>>> print(calendar.TextCalendar(calendar.MONDAY).formatyear(2017,2, 1, 1, 2))








PyPI y pip
El Python Package Index o PyPI, es el repositorio de paquetes de software oficial para aplicaciones de terceros en el lenguaje de programación Python.

pip: Sistema de gestión de paquetes utilizado para instalar y administrar paquetes de software escritos en Python que se encuentran alojados en el repositorio PyPI.

Instalación de módulos python
Para instalar un nuevo paquete python tengo varias alternativas:

Utilizar el que este empaquetado en la distribución que estés usando. Podemos tener problemas si necesitamos una versión determinada.

 # apt-cache show python3-requests
 ...
 Version: 2.4.3-6
 ...
Instalar pip en nuestro equipo, y como superusuario instalar el paquete python que nos interesa. Esta solución nos puede dar muchos problemas, ya que podemos romper las dependencias entre las versiones de nuestros paquetes python instalados en el sistema y algún paquete puede dejar de funcionar.

 # pip search requests
 ...
 requests (2.13.0)      - Python HTTP for Humans.
 ...
Utilizar entornos virtuales: es un mecanismo que me permite gestionar programas y paquetes python sin tener permisos de administración, es decir, cualquier usuario sin privilegios puede tener uno o más “espacios aislados” (ya veremos más adelante que los entornos virtuales se guardan en directorios) donde poder instalar distintas versiones de programas y paquetes python. Para crear los entornos virtuales vamos a usar el programa virtualenv o el módulo venv.

Creando entornos virtuales con virtualenv
Podemos utilizar este software para trabajar con cualquier distribución de python, pero evidentemente es obligatorio si estamos trabajando con python 2.x o python 3.x (una versión anterior a la 3.3).

# apt-get install python-virtualenv
Si queremos crear un entorno virtual con python3:

$ virtualenv -p /usr/bin/python3 entorno2
La opción -p nos permite indicar el interprete que se va a utilizar en el entorno.

Para activar nuestro entorno virtual:

$ source entorno2/bin/activate
(entorno2)$ 
Y para desactivarlo:

(entorno2)$ deactivate
$
Creando entornos virtuales con venv
A partir de la versión 3.3 de python podemos utilizar el módulo venv para crear el entorno virtual.

Instalamos el siguiente paquete para instalar el módulos:

# apt-get install python3-venv
Ahora ya como un usuario sin privilegio podemos crear un entorno virtual con python3:

$ python3 -m venv entorno3
La opción -m del interprete nos permite ejecutar un módulo como si fuera un programa.

Para activar y desactivar el entono virtual:

$ source entorno3/bin/activate
(entorno3)$ deactivate
$ 
Instalando paquetes en nuestro entorno virtual
Independientemente del sistema utilizado para crear nuestro entorno virtual, una vez que lo tenemos activado podemos instalar paquetes python en él utilizando la herramienta pip (que la tenemos instalada automáticamente en nuestro entorno). Partiendo de un entorno activado, podemos, por ejemplo, instalar la última versión de django:

(entorno3)$ pip install django
Si queremos ver los paquetes que tenemos instalados con sus dependencias:

(entorno3)$ pip list
Django (1.10.5)
pip (1.5.6)
setuptools (5.5.1)
Si necesitamos buscar un paquete podemos utilizar la siguiente opción:

(entorno3)$ pip search requests
Si a continuación necesitamos instalar una versión determinada del paquete, que no sea la última, podemos hacerlo de la siguiente manera:

(entorno3)$ pip install requests=="2.12"
Si necesitamos borrar un paquete podemos ejecutar:

(entorno3)$ pip uninstall requests
Y, por supuesto para instalar la última versión, simplemente:

(entorno3)$ pip install requests    
Para terminar de repasar la herramienta pip, vamos a explicar como podemos guardar en un fichero (que se suele llamar requirements.txt) la lista de paquetes instalados, que nos permite de manera sencilla crear otro entorno virtual en otra máquina con los mismos paquetes instalados. Para ello vamos a usar la siguiente opción de pip:

(entorno3)$ pip freeze
Django==1.10.5
requests==2.13.0
Y si queremos guardar esta información en un fichero que podamos distribuir:

(entorno3)$ pip freeze > requirements.txt
De tal manera que otro usuario, en otro entorno, teniendo este fichero pude reproducirlo e instalar los mismos paquetes de la siguiente manera:

(entorno4)$ pip install -r requirements.txt









Introducción a la programación estructurada y modular
La programación estructurada es un paradigma de programación orientado a mejorar la claridad, calidad y tiempo de desarrollo de un programa de ordenador, utilizando únicamente subrutinas (funciones o procedimientos) y tres estructuras: secuencia, alternativas y repetitivas.

La programación modular es un paradigma de programación que consiste en dividir un programa en módulos o subprogramas con el fin de hacerlo más legible y manejable.

Al aplicar la programación modular, un problema complejo debe ser dividido en varios subproblemas más simples, y estos a su vez en otros subproblemas más simples. Esto debe hacerse hasta obtener subproblemas lo suficientemente simples como para poder ser resueltos fácilmente con algún lenguaje de programación (divide y vencerás).

La programación estructural y modular se lleva a cabo en python3 con la definición de funciones.

Definición de funciones
Veamos un ejemplo de definición de función:

>>> def factorial(n):
...   """Calcula el factorial de un número"""
...   resultado = 1
...   for i in range(1,n+1):
...     resultado*=i
...   return resultado
Podemos obtener información de la función:

>>> help(factorial)
Help on function factorial in module __main__:
factorial(n)
    Calcula el factorial de un número
Y para utilizar la función:

>>> factorial(5)
120
Ámbito de variables. Sentencia global
Una variable local se declara en su ámbito de uso (en el programa principal y dentro de una función) y una global fuera de su ámbito para que se pueda utilizar en cualquier función que la declare como global.

>>> def operar(a,b):
...    global suma
...    suma = a + b
...    resta = a - b
...    print(suma,resta)
... 
>>> operar(4,5)
9 -1
>>> resta
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'resta' is not defined
>>> suma
9
Podemos definir variables globales, que serán visibles en todo el módulo. Se recomienda declararlas en mayúsculas:

>>> PI = 3.1415
>>> def area(radio):
...    return PI*radio**2
... 
>>> area(2)
12.566
Parámetros formales y reales
Parámetros formales: Son las variables que recibe la función, se crean al definir la función. Su contenido lo recibe al realizar la llamada a la función de los parámetro reales. Los parámetros formales son variables locales dentro de la función.

Parámetros reales: Son la expresiones que se utilizan en la llamada de la función, sus valores se copiarán en los parámetros formales.

Paso de parámetro por valor o por referencia
En Python el paso de parámetros es siempre por referencia. El lenguaje no trabaja con el concepto de variables sino objetos y referencias. Al realizar la asignación a = 1 no se dice que “a contiene el valor 1” sino que “a referencia a 1”. Así, en comparación con otros lenguajes, podría decirse que en Python los parámetros siempre se pasan por referencia.

Evidentemente si se pasa un valor de un objeto inmutable, su valor no se podrá cambiar dentro de la función:

>>> def f(a):
...     a=5
>>> a=1
>>> f(a)
>>> a
1
Sin embargo si pasamos un objeto de un tipo mutable, si podremos cambiar su valor:

>>> def f(lista):
...   lista.append(5)
... 
>>> l = [1,2]
>>> f(l)
>>> l
[1, 2, 5]
Aunque podemos cambiar el parámetro real cuando los objetos pasados son de tipo mutables, no es recomendable hacerlo en Python. En otros lenguajes es necesario porque no tenemos opción de devolver múltiples valores, pero como veremos en Python podemos devolver tuplas o lista con la instrucción return.

Llamadas a una función
Cuando se llama a una función se tienen que indicar los parámetros reales que se van a pasar. La llamada a una función se puede considerar una expresión cuyo valor y tipo es el retornado por la función. Si la función no tiene una instrucción return el tipo de la llamada sera None.

>>> def cuadrado(n):
...   return n*n

>>> a=cuadrado(2)
>>> cuadrado(3)+1
10
>>> cuadrado(cuadrado(4))
256
>>> type(cuadrado(2))
<class 'int'>
Cuando estamos definiendo una función estamos creando un objeto de tipo function.

>>> type(cuadrado)
<class 'function'>
Y por lo tanto puedo guardar el objeto función en otra variable:

>>> c=cuadrado
>>> c(4)
16














// Tipos de argumentos: posicionales o keyword

Tenemos dos tipos de parámetros: los posiciónales donde el parámetro real debe coincidir en posición con el parámetro formal:

>>> def sumar(n1,n2):
...   return n1+n2
... 
>>> sumar(5,7)
12
>>> sumar(4)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: sumar() missing 1 required positional argument: 'n2'
Además podemos tener parámetros con valores por defecto:

>>> def operar(n1,n2,operador='+',respuesta='El resultado es '):
...   if operador=="+":
...     return respuesta+str(n1+n2)
...   elif operador=="-":
...     return respuesta+str(n1-n2)
...   else:
...     return "Error"
... 
>>> operar(5,7)
'El resultado es 12'
>>> operar(5,7,"-")
'El resultado es -2'
>>> operar(5,7,"-","La resta es ")
'La resta es -2'
Los parámetros keyword son aquellos donde se indican el nombre del parámetro formal y su valor, por lo tanto no es necesario que tengan la misma posición. Al definir una función o al llamarla, hay que indicar primero los argumentos posicionales y a continuación los argumentos con valor por defecto (keyword).

>>> operar(5,7)    # dos parámetros posicionales
>>> operar(n1=4,n2=6)    # dos parámetros keyword
>>> operar(4,6,respuesta="La suma es")    # dos parámetros posicionales y uno keyword
>>> operar(4,6,respuesta="La resta es",operador="-")    # dos parámetros posicionales y dos keyword
Parámetro *
Un parámetro * entre los parámetros formales de una función, nos obliga a indicar los parámetros reales posteriores como keyword:

>>> def sumar(n1,n2,*,op="+"):
...   if op=="+":
...     return n1+n2
...   elif op=="-":
...     return n1-n2
...   else:
...     return "error"
... 
>>> sumar(2,3)
5
>>> sumar(2,3,"-")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: sumar() takes 2 positional arguments but 3 were given
>>> sumar(2,3,op="-")
-1
Argumentos arbitrarios (*args y **kwargs)
Para indicar un número indefinido de argumentos posicionales al definir una función, utilizamos el símbolo *:

>>> def sumar(n,*args):
...   resultado=n
...   for i in args:
...     resultado+=i
...   return resultado
... 
>>> sumar(2)
2
>>> sumar(2,3,4)
9
Para indicar un número indefinido de argumentos keyword al definir una función, utilizamos el símbolo **:

>>> def saludar(nombre="pepe",**kwargs):
...   cadena=nombre
...   for valor in kwargs.values():
...    cadena=cadena+" "+valor
...   return "Hola "+cadena
... 
>>> saludar()
'Hola pepe'
>>> saludar("juan")
'Hola juan'
>>> saludar(nombre="juan",nombre2="pepe")
'Hola juan pepe'
>>> saludar(nombre="juan",nombre2="pepe",nombre3="maria")
'Hola juan maria pepe'
Por lo tanto podríamos tener definiciones de funciones del tipo:

>>> def f()
>>> def f(a,b=1)
>>> def f(a,*args,b=1)
>>> def f(*args,b=1)
>>> def f(*args,b=1,*kwargs)
>>> def f(*args,*kwargs)
>>> def f(*args)
>>> def f(*kwargs)
Desempaquetar argumentos: pasar listas y diccionarios
En caso contrario es cuando tenemos que pasar parámetros que lo tenemos guardados en una lista o en un diccionario.

Para pasar listas utilizamos el símbolo *:

>>> lista=[1,2,3]
>>> sumar(*lista)
6
>>> sumar(2,*lista)
8
>>> sumar(2,3,*lista)
11
Podemos tener parámetros keyword guardados en un diccionario, para enviar un diccionario utilizamos el símbolo **:

>>> datos={"nombre":"jose","nombre2":"pepe","nombre3":"maria"}
>>> saludar(**datos)
'Hola jose maria pepe'
Devolver múltiples resultados
La instrucción return puede devolver cualquier tipo de resultados, por lo tanto es fácil devolver múltiples datos guardados en una lista o en un diccionario. Veamos un ejemplo en que devolvemos los datos en una tupla:

>>> def operar(n1,n2):
...   return (n1+n2,n1-n2,n1*n2)    

>>> suma,resta,producto = operar(5,2)
>>> suma
7
>>> resta
3
>>> producto
10















Funciones lambda
Las funciones lambda nos sirven para crear pequeñas funciones anónimas, de una sola línea sobre la marcha.

>>> cuadrado = lambda x: x**2
>>> cuadrado(2)
Como podemos notar las funciones lambda no tienen nombre. Pero gracias a que lambda crea una referencia a un objeto función, la podemos llamar.

>>> lambda x: x**2
<function <lambda> at 0xb74469cc>
>>>
>>> (lambda x: x**2)(3)
9
Otro ejemplo:

>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
>>> pairs.sort(key=lambda pair: pair[1])
>>> pairs
[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]

Decoradores
Los decoradores son funciones que reciben como parámetros otras funciones y retornan como resultado otras funciones con el objetivo de alterar el funcionamiento original de la función que se pasa como parámetro. Hay funciones que tienen en común muchas funcionalidades, por ejemplo las de manejo de errores de conexión de recursos I/O (que se deben programar siempre que usemos estos recursos) o las de validación de permisos en las respuestas de peticiones de servidores, en vez de repetir el código de rutinas podemos abstraer, bien sea el manejo de error o la respuesta de peticiones, en una función decorador.

>>> def tablas(funcion):
...     def envoltura(tabla=1):
...         print('Tabla del %i:' %tabla)
...         print('-' * 15)
...         for numero in range(0, 11):            
...             funcion(numero, tabla)
...         print('-' * 15)
...     return envoltura
... 
>>> @tablas
... def suma(numero, tabla=1):
...     print('%2i + %2i = %3i' %(tabla, numero, tabla+numero))
... 
>>> @tablas
... def multiplicar(numero, tabla=1):
...     print('%2i X %2i = %3i' %(tabla, numero, tabla*numero))

# Muestra la tabla de sumar del 1
suma()    
# Muestra la tabla de sumar del 4 
suma(4)    
# Muestra la tabla de multiplicar del 1
multiplicar()    
# Muestra la tabla de multiplicar del 10
multiplicar(10)  

Funciones generadoras
Un generador es un tipo concreto de iterador. Es una función que permite obtener sus resultados paso a paso.

>>> def par(inicio,fin):
...   for i in range(inicio,fin):
...     if i % 2==0:
...       yield i

>>> datos = par(1,5)
>>> next(datos)
2
>>> next(datos)
4

>>> for i in par(20,30):
...   print(i,end=" ")
20 22 24 26 28

>>> lista_pares = list(par(1,10))
>>> lista_pares
[2, 4, 6, 8]













Propiedades: getters, setters, deleter
Para implementar la encapsulación y no permitir el acceso directo a los atributos, podemos poner los atributos ocultos y declarar métodos especificos para acceder y modificar los atributos (mutadores). Estos métodos se denominan getters y setters.

class circulo():
    def __init__(self,radio):
        self.set_radio(radio)
    def set_radio(self,radio):
        if radio>=0:
            self._radio = radio
        else:
            raise ValueError("Radio positivo")
            self._radio=0
    def get_radio(self):
        print("Estoy dando el radio")
        return self._radio

>>> c1=circulo(3)
>>> c1.get_radio()
Estoy dando el radio
3
>>> c1.set_radio(-1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/jose/github/curso_python3/curso/u51/circulo.py", line 8, in set_radio
    raise ValueError("Radio positivo")
ValueError: Radio positivo
En Python, las propiedades nos permiten implementar la funcionalidad exponiendo estos métodos como atributos.

class circulo():
    def __init__(self,radio):
        self.radio=radio

    @property
    def radio(self):
        print("Estoy dando el radio")
        return self._radio    

    @radio.setter
    def radio(self,radio):
        if radio>=0:
            self._radio = radio
        else:
            raise ValueError("Radio positivo")
            self._radio=0


>>> c1=circulo(3)
>>> c1.radio
Estoy dando el radio
3
>>> c1.radio=4
>>> c1.radio=-1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/jose/github/curso_python3/curso/u52/circulo2.py", line 15, in radio
    raise ValueError("Radio positivo")
ValueError: Radio positivo
Hay un tercera property que podemos crear: el deleter

...
@radio.deleter
def radio(self):
    del self._radio


>>> c1=circulo(3)
>>> c1.radio
Estoy dando el radio
3
>>> del c1.radio
>>> c1.radio
Estoy dando el radio
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/jose/github/curso_python3/curso/u52/circulo2.py", line 8, in radio
    return self._radio
AttributeError: 'circulo' object has no attribute '_radio'
>>> c1.radio=3
Representación de objetos __str__ y __repr__
La documentación de Python hace referencia a que el método __str()__ ha de devolver la representación “informal” del objeto, mientras que __repr()__ la “formal”.

La función __str()__ debe devolver la cadena de texto que se muestra por pantalla si llamamos a la función str(). Esto es lo que hace Python cuando usamos print. Suele devolver el nombre de la clase.
De __repr()__, por el otro lado, se espera que nos devuelva una cadena de texto con una representación única del objeto. Idealmente, la cadena devuelta por __repr()__ debería ser aquella que, pasada a eval(), devuelve el mismo objeto.
Continuamos con la clase circulo:

...
def __str__(self):
    clase = type(self).__name__
    msg = "{0} de radio {1}"
    return msg.format(clase, self.radio)

def __repr__(self):
    clase = type(self).__name__
    msg = "{0}({1})"
    return msg.format(clase, self.radio)
Suponemos que estamos utilizando la clase circulo sin la instrucción print en el getter.

>>> c1=circulo(3)
>>> print(c1)
circulo de radio 3
>>> repr(c1)
'circulo(3)'
>>> type(eval(repr(c1)))
<class 'circulo2.circulo'>
Comparación de objetos __eq__
Tampoco podemos comparar dos circulos sin definir __eq()__, ya que sin este método Python comparará posiciones en memoria.

Continuamos con la clase circulo:

...
def __eq__(self,otro):
    return self.radio==otro.radio

>>> c1=circulo(5)
>>> c2=circulo(3)
>>> c1 == c2
False
Si queremos utilizar <, <=, > y >= tendremos que rescribir los métodos: __lt()__, __le()__, __gt()__ y __ge()__

Operar con objetos __add__ y __sub__
Si queremos operar con los operadores + y -:

def __add__(self,otro):
    self.radio+=otro.radio

def __sub__(self,otro):
    if self.radio-otro.radio>=0:
        self.radio-=otro.radio
    else:
        raise ValueError("No se pueden restar")

>>> c1=circulo(5)
>>> c2=circulo(3)
>>> c1 + c2
>>> c1.radio
8    


>>> c1=circulo(5)
>>> c2=circulo(3)
>>> c1 - c2
>>> c1.radio
2
>>> c1 - c2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/jose/github/curso_python3/curso/u52/circulo2.py", line 42, in __sub__
    raise ValueError("No se pueden restar")
ValueError: No se pueden restar
Más métodos especiales
Existen muchos más métodos especiales que podemos sobreescibir en nuestras clases para añadir funcionalidad a las mismas. Puedes ver la documentación oficial para aprender más sobre ellas.















Polimorfismo
El polimorfismo es la técnica que nos posibilita que al invocar un determinado método de un objeto, podrán obtenerse distintos resultados según la clase del objeto. Esto se debe a que distintos objetos pueden tener un método con un mismo nombre, pero que realice distintas operaciones.

Lo llevamos usando desde principio del curso, por ejemplo podemos recorrer con una estructura for distintas clases de objeto, debido a que el método especial __iter__ está definida en cada una de las clases. Otro ejemplo sería que con la función print podemos imprimir distintas clases de objeto, en este caso, el método especial __str__ está definido en todas las clases.

Además esto es posible a que python es dinámico, es decir en tiempo de ejecución es cuando se determina el tipo de un objeto. Veamos un ejemplo:

class gato():
    def hablar(self):
        print("MIAU")    

class perro():
    def hablar(self):
        print("GUAU")    

def escucharMascota(animal):
    animal.hablar()    

if __name__ == '__main__':
    g = gato()
    p = perro()
    escucharMascota(g)
    escucharMascota(p)
Herencia
La herencia es un mecanismo de la programación orientada a objetos que sirve para crear clases nuevas a partir de clases preexistentes. Se toman (heredan) atributos y métodos de las clases viejas y se los modifica para modelar una nueva situación.

La clase desde la que se hereda se llama clase base y la que se construye a partir de ella es una clase derivada.

Si nuestra clase base es la clase punto estudiadas en unidades anteriores, puedo crear una nueva clase de la siguiente manera:

class punto3d(punto):
    def __init__(self,x=0,y=0,z=0):
        super().__init__(x,y)
        self.z=z
    @property
    def z(self):
        return self._z    

    @z.setter
    def z(self,z):
        self._z=z    

    def __str__(self):
        return super().__str__()+":"+str(self.z)    

    def distancia(self,otro):
        dx = self.x - otro.x
        dy = self.y - otro.y
        dz = self.z - otro.z
        return (dx*dx + dy*dy + dz*dz)**0.5    
Creemos dos objetos de cada clase y veamos los atributos y métodos que tienen definido:

>>> p=punto(1,2)
>>> dir(p)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_x', '_y', 'distancia', 'x', 'y']
>>> p3d=punto3d(1,2,3)
>>> dir(p3d)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_x', '_y', '_z', 'distancia', 'x', 'y', 'z']
La función super()
La función super() me proporciona una referencia a la clase base. Y podemos observar también que hemos reescrito el método distancia y __str__.

>>> p.distancia(punto(5,6))
5.656854249492381
>>> p3d.distancia(punto3d(2,3,4))
1.7320508075688772
>>> print(p)
1:2
>>> print(p3d)
1:2:3
Herencia múltiple
La herencia múltiple se refiere a la posibilidad de crear una clase a partir de múltiples clases superiores. Es importante nombrar adecuadamente los atributos y los métodos en cada clase para no crear conflictos.

class Telefono:
    "Clase teléfono"
    def __init__(self,numero):
        self.numero=numero
    def telefonear(self):
        print('llamando')
    def colgar(self):
        print('colgando') 
    def __str__(self):
        return self.numero    

class Camara:
    "Clase camara fotográfica"
    def __init__(self,mpx):
        self.mpx=mpx
    def fotografiar(self):
        print('fotografiando')        
    def __str__(self):
        return self.mpx
class Reproductor:
    "Clase Reproductor Mp3"
    def __init__(self,capcidad):
        self.capacidad=capcidad
    def reproducirmp3(self):
        print('reproduciendo mp3')                  
    def reproducirvideo(self):
        print('reproduciendo video')                  
    def __str__(self):
        return self.capacidad    

class Movil(Telefono, Camara, Reproductor):
    def __init__(self,numero,mpx,capacidad):
        Telefono.__init__(self,numero)
        Camara.__init__(self,mpx)
        Reproductor.__init__(self,capacidad)
    def __str__(self):
        return "Número: {0}, Cámara: {1},Capacidad: {2}".format(Telefono.__str__(self),Camara.__str__(self),Reproductor.__str__(self))
Veamos los atributos y métodos de un objeto Movil:

>>> mimovil=Movil("645234567","5Mpx","1G")
>>> dir(mimovil)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'capacidad', 'colgar', 'fotografiar', 'mpx', 'numero', 'reproducirmp3', 'reproducirvideo', 'telefonear']
>>> print(mimovil)
Número: 645234567, Cámara: 5Mpx,Capacidad: 1G
Funciones issubclass() y isinstance()
La función issubclass(SubClase, ClaseSup) se utiliza para comprobar si una clase (SubClase) es hija de otra superior (ClaseSup), devolviendo True o False según sea el caso.

>>> issubclass(Movil,Telefono)
True
La función booleana isinstance(Objeto, Clase) se utiliza para comprobar si un objeto pertenece a una clase o clase superior.

>>> isinstance(mimovil,Movil)
True
Delegación
Llamamos delegación a la situación en la que una clase contiene (como atributos) una o más instancias de otra clase, a las que delegará parte de sus funcionalidades.

A partir de la clase punto, podemos crear la clase circulo de esta forma:

class circulo():    

    def __init__(self,centro,radio):
        self.centro=centro
        self.radio=radio    

    def __str__(self):
        return "Centro:{0}-Radio:{1}".format(self.centro.__str__(),self.radio)    
Y creamos un objeto circulo:

>>> c1=circulo(punto(2,3),5)
>>> print(c1)
Centro:2:3-Radio:5












	